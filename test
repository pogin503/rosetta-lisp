testsuites/syntax:1
PARSE_SUCCESS 1 1
foo
foo
testsuites/syntax:4
PARSE_SUCCESS 1 1
abc123
abc123
testsuites/syntax:7
PARSE_SUCCESS 1 1
foo-bar
foo-bar
testsuites/syntax:10
PARSE_SUCCESS 1 1
*foo*
*foo*
testsuites/syntax:13
PARSE_SUCCESS 1 1
x
x
testsuites/syntax:16
PARSE_SUCCESS 1 1
x1.y2:
x1.y2:
testsuites/syntax:19
PARSE_SUCCESS 1 1
the-Answer-to-the-Ultimate-Question
the-Answer-to-the-Ultimate-Question
testsuites/syntax:22
PARSE_SUCCESS 1 1
0
0
testsuites/syntax:25
PARSE_SUCCESS 1 1
1234
1234
testsuites/syntax:28
PARSE_SUCCESS 1 1
3.5
3.5
testsuites/syntax:31
PARSE_SUCCESS 1 1
+732
732
testsuites/syntax:34
PARSE_SUCCESS 1 1
-42
-42
testsuites/syntax:37
PARSE_SUCCESS 1 1
13e2
1300
testsuites/syntax:40
PARSE_SUCCESS 1 1
9e+1
90
testsuites/syntax:43
PARSE_SUCCESS 1 1
125e-1
12.5
testsuites/syntax:46
PARSE_SUCCESS 1 1
"foo"
"foo"
testsuites/syntax:49
PARSE_SUCCESS 1 1
"Hello, World!"
"Hello, World!"
testsuites/syntax:52
PARSE_SUCCESS 1 1
"( ) . 0 a"
"( ) . 0 a"
testsuites/syntax:55
PARSE_SUCCESS 1 1
"foo\nbar"
"foo\nbar"
testsuites/syntax:58
PARSE_SUCCESS 2 1
"foo
bar"
"foo\nbar"
testsuites/syntax:62
PARSE_SUCCESS 1 1
"A \" B"
"A \" B"
testsuites/syntax:65
PARSE_SUCCESS 1 1
"A\t	B"
"A\t\tB"
testsuites/syntax:68
PARSE_SUCCESS 1 1
"\\\\"
"\\\\"
testsuites/syntax:71
PARSE_SUCCESS 1 1
()
()
testsuites/syntax:74
PARSE_SUCCESS 1 1
[]
()
testsuites/syntax:77
PARSE_SUCCESS 1 1
(foo . bar)
(foo . bar)
testsuites/syntax:80
PARSE_SUCCESS 1 1
(1 2 . 3)
(1 2 . 3)
testsuites/syntax:83
PARSE_SUCCESS 1 1
(a b c d)
(a b c d)
testsuites/syntax:86
PARSE_SUCCESS 1 1
(foo [bar (baz)])
(foo (bar (baz)))
testsuites/syntax:89
PARSE_SUCCESS 1 1
(#t #f)
(#t #f)
testsuites/syntax:92
PARSE_SUCCESS 1 1
'foo
'foo
testsuites/syntax:95
PARSE_SUCCESS 1 1
'(foo 123)
'(foo 123)
testsuites/syntax:98
PARSE_SUCCESS 1 1
`(i ,j ,@(k l))
`(i ,j ,@(k l))
testsuites/syntax:101
PARSE_SUCCESS 1 1
       123      
123
testsuites/syntax:104
PARSE_SUCCESS 3 1
; hello
; world
()
()
testsuites/syntax:109
PARSE_SUCCESS 2 1
(foo ; comment
bar) ; comment
(foo bar)
testsuites/syntax:113
PARSE_SUCCESS 4 1
(this
is
the
last)
(this is the last)
testsuites/compiler:1
COMPILE_SUCCESS 1 2
123
[0 entry]
  ldc 123
testsuites/compiler:5
COMPILE_SUCCESS 1 2
"foo"
[0 entry]
  ldc "foo"
testsuites/compiler:9
COMPILE_SUCCESS 1 2
foo
[0 entry]
  ldv foo
testsuites/compiler:13
COMPILE_SUCCESS 1 3
(foo)
[0 entry]
  ldv foo
  app 0
testsuites/compiler:18
COMPILE_SUCCESS 1 5
(foo bar baz)
[0 entry]
  ldv foo
  ldv bar
  ldv baz
  app 2
testsuites/compiler:25
COMPILE_SUCCESS 1 8
(foo (bar (baz)) hoge)
[0 entry]
  ldv foo
  ldv bar
  ldv baz
  app 0
  app 1
  ldv hoge
  app 2
testsuites/compiler:35
COMPILE_FAILURE 1
(foo . bar)
testsuites/compiler:38
COMPILE_FAILURE 1
(a b c . d)
testsuites/compiler:41
COMPILE_SUCCESS 1 2
(begin)
[0 entry]
  ldc ()
testsuites/compiler:45
COMPILE_SUCCESS 1 2
(begin x)
[0 entry]
  ldv x
testsuites/compiler:49
COMPILE_SUCCESS 1 4
(begin x y)
[0 entry]
  ldv x
  pop
  ldv y
testsuites/compiler:55
COMPILE_SUCCESS 1 8
(begin a (b c) d)
[0 entry]
  ldv a
  pop
  ldv b
  ldv c
  app 1
  pop
  ldv d
testsuites/compiler:65
COMPILE_SUCCESS 1 4
(def hello 123)
[0 entry]
  ldc 123
  def hello
  ldc ()
testsuites/compiler:71
COMPILE_SUCCESS 1 6
(def hello (a b))
[0 entry]
  ldv a
  ldv b
  app 1
  def hello
  ldc ()
testsuites/compiler:79
COMPILE_SUCCESS 1 6
(set! goodbye (c d))
[0 entry]
  ldv c
  ldv d
  app 1
  set goodbye
  ldc ()
testsuites/compiler:87
COMPILE_FAILURE 1
(def hello)
testsuites/compiler:90
COMPILE_FAILURE 1
(def (foo bar) 123)
testsuites/compiler:93
COMPILE_FAILURE 1
(def "string" 42)
testsuites/compiler:96
COMPILE_SUCCESS 1 9
(if a b c)
[0 entry]
  ldv a
  sel [1 then] [2 else]
[1 then]
  ldv b
  leave
[2 else]
  ldv c
  leave
testsuites/compiler:107
COMPILE_FAILURE 1
(if a b)
testsuites/compiler:110
COMPILE_SUCCESS 1 13
(if (a b) (x y) z)
[0 entry]
  ldv a
  ldv b
  app 1
  sel [1 then] [2 else]
[1 then]
  ldv x
  ldv y
  app 1
  leave
[2 else]
  ldv z
  leave
testsuites/compiler:125
COMPILE_SUCCESS 1 30
(if (if a b c) (if d e f) (if g h i))
[0 entry]
  ldv a
  sel [1 then] [2 else]
  sel [3 then] [6 else]
[1 then]
  ldv b
  leave
[2 else]
  ldv c
  leave
[3 then]
  ldv d
  sel [4 then] [5 else]
  leave
[4 then]
  ldv e
  leave
[5 else]
  ldv f
  leave
[6 else]
  ldv g
  sel [7 then] [8 else]
  leave
[7 then]
  ldv h
  leave
[8 else]
  ldv i
  leave
testsuites/compiler:157
COMPILE_FAILURE 1
(if a b c d)
testsuites/compiler:160
COMPILE_SUCCESS 1 5
(fun ())
[0 entry]
  ldf [1 fun ()]
[1 fun ()]
  ldc ()
  leave
testsuites/compiler:167
COMPILE_SUCCESS 1 7
(fun () 12 34)
[0 entry]
  ldf [1 fun ()]
[1 fun ()]
  ldc 12
  pop
  ldc 34
  leave
testsuites/compiler:176
COMPILE_FAILURE 1
(fun "x")
testsuites/compiler:179
COMPILE_SUCCESS 1 5
(fun abc)
[0 entry]
  ldf [1 fun abc]
[1 fun abc]
  ldc ()
  leave
testsuites/compiler:186
COMPILE_SUCCESS 1 5
(fun (a b . c))
[0 entry]
  ldf [1 fun (a b . c)]
[1 fun (a b . c)]
  ldc ()
  leave
testsuites/compiler:193
COMPILE_SUCCESS 1 5
(fun (x y) z)
[0 entry]
  ldf [1 fun (x y)]
[1 fun (x y)]
  ldv z
  leave
testsuites/compiler:200
COMPILE_FAILURE 1
(fun (0))
testsuites/compiler:203
COMPILE_SUCCESS 1 4
(macro ())
[0 entry]
  ldm [1 macro ()]
[1 macro ()]
  ldc ()
testsuites/compiler:209
COMPILE_SUCCESS 1 4
(macro (x y) x)
[0 entry]
  ldm [1 macro (x y)]
[1 macro (x y)]
  ldv x
testsuites/compiler:215
COMPILE_SUCCESS 1 2
(builtin hello)
[0 entry]
  ldb hello
testsuites/compiler:219
COMPILE_FAILURE 1
(builtin "hello")
testsuites/compiler:222
COMPILE_SUCCESS 1 2
'(1 2 3)
[0 entry]
  ldc (1 2 3)
testsuites/compiler:226
COMPILE_FAILURE 1
(quote a b)
testsuites/vm:1
EVAL_SUCCESS 1 1
123
123
testsuites/vm:4
EVAL_SUCCESS 1 1
'hoge
hoge
testsuites/vm:7
EVAL_SUCCESS 1 1
(begin 123 456 789)
789
testsuites/vm:10
EVAL_FAILURE 1
foo
testsuites/vm:13
EVAL_SUCCESS 1 1
(def foo "foo")
()
testsuites/vm:16
EVAL_SUCCESS 1 1
foo
"foo"
testsuites/vm:19
EVAL_SUCCESS 1 1
(def foo "bar")
()
testsuites/vm:22
EVAL_SUCCESS 1 1
foo
"bar"
testsuites/vm:25
EVAL_SUCCESS 1 1
(set! foo "baz")
()
testsuites/vm:28
EVAL_SUCCESS 1 1
foo
"baz"
testsuites/vm:31
EVAL_FAILURE 1
(set! hoge "fuga")
testsuites/vm:34
EVAL_SUCCESS 1 1
(fun () 123)
<fun>
testsuites/vm:37
EVAL_SUCCESS 1 1
((fun () 123))
123
testsuites/vm:40
EVAL_FAILURE 1
((fun (a b) a) 12)
testsuites/vm:43
EVAL_SUCCESS 1 1
((fun (a b) a) 12 34)
12
testsuites/vm:46
EVAL_FAILURE 1
((fun (a b) a) 12 34 56)
testsuites/vm:49
EVAL_FAILURE 1
((fun (a . b) b))
testsuites/vm:52
EVAL_SUCCESS 1 1
((fun (a . b) a) 12)
12
testsuites/vm:55
EVAL_SUCCESS 1 1
((fun (a . b) b) 12)
()
testsuites/vm:58
EVAL_SUCCESS 1 1
((fun (a . b) b) 12 34 56)
(34 56)
testsuites/vm:61
EVAL_SUCCESS 1 1
((fun a a) 12 34)
(12 34)
testsuites/vm:64
EVAL_SUCCESS 1 1
(set! foo #t)
()
testsuites/vm:66
EVAL_SUCCESS 1 1
((fun () (def foo #f)))
()
testsuites/vm:68
EVAL_SUCCESS 1 1
foo
#t
testsuites/vm:71
EVAL_SUCCESS 1 1
((fun () (set! foo #f)))
()
testsuites/vm:73
EVAL_SUCCESS 1 1
foo
#f
testsuites/vm:76
EVAL_SUCCESS 1 1
(def _list (fun a a))
()
testsuites/vm:78
EVAL_SUCCESS 1 1
(_list 1 (_list 2 3) 4)
(1 (2 3) 4)
testsuites/vm:81
EVAL_SUCCESS 1 1
(set! foo 0)
()
testsuites/vm:83
EVAL_SUCCESS 1 1
(set! foo (_list foo 1))
()
testsuites/vm:85
EVAL_SUCCESS 1 1
foo
(0 1)
testsuites/vm:88
EVAL_SUCCESS 6 1
(begin
  (set! foo 0)
  (set! foo (_list foo 1))
  (set! foo (_list foo 2))
  (set! foo (_list foo 3))
  foo)
(((0 1) 2) 3)
testsuites/vm:96
EVAL_SUCCESS 1 1
(if #t 123 456)
123
testsuites/vm:99
EVAL_SUCCESS 1 1
(if #f 123 456)
456
testsuites/vm:102
EVAL_SUCCESS 1 1
(if "anything except #f" 123 456)
123
testsuites/vm:105
EVAL_SUCCESS 1 1
(if () 123 456)
123
testsuites/vm:108
EVAL_SUCCESS 1 1
(if #t (def hoge "fuga") (def hoge "fuga"))
()
testsuites/vm:110
EVAL_FAILURE 1
hoge
testsuites/vm:113
EVAL_SUCCESS 6 1
(begin
  (set! foo 0)
  (if #t
    (set! foo (_list foo 1))
    (set! foo (_list foo 2)))
  foo)
(0 1)
testsuites/vm:121
EVAL_SUCCESS 6 1
(begin
  (set! foo 0)
  (if #f
    (set! foo (_list foo 1))
    (set! foo (_list foo 2)))
  foo)
(0 2)
testsuites/vm:129
EVAL_SUCCESS 1 1
(macro (a b) a)
<macro>
testsuites/vm:132
EVAL_FAILURE 1
((macro (a b) a) 12 34)
testsuites/vm:135
EVAL_SUCCESS 1 1
(def _skip (macro (a . b) b))
()
testsuites/vm:137
EVAL_SUCCESS 1 1
(_skip 12 _list 34 56)
(34 56)
testsuites/vm:140
EVAL_SUCCESS 1 1
(set! foo #t)
()
testsuites/vm:142
EVAL_SUCCESS 1 1
(_skip (set! foo #f) _list)
()
testsuites/vm:144
EVAL_SUCCESS 1 1
foo
#t
testsuites/vm:147
EVAL_SUCCESS 1 1
(_skip 12 _skip 34 _list 56 78)
(56 78)
testsuites/vm:150
EVAL_SUCCESS 1 1
(_list 12 (_skip 34 _list 56 78))
(12 (56 78))
boot.lisp:1
EVAL_ALL 1
(def cons (builtin cons))
boot.lisp:2
EVAL_FAILURE 1
(cons 1)
boot.lisp:4
EVAL_SUCCESS 1 1
(cons 1 2)
(1 . 2)
boot.lisp:6
EVAL_FAILURE 1
(cons 1 2 3)
boot.lisp:8
EVAL_ALL 6

(def list (fun xs xs))

(def defun (macro (sym . body) (list 'def sym (cons 'fun body))))
(def defmacro (macro (sym . body) (list 'def sym (cons 'macro body))))
(def defbuiltin (macro (sym . intf) (list 'def sym (list 'builtin sym))))
boot.lisp:14
EVAL_SUCCESS 1 1
(defun _f (a b) b)
()
boot.lisp:16
EVAL_SUCCESS 1 1
(_f 3 5)
5
boot.lisp:18
EVAL_SUCCESS 1 1
(defmacro _m (a . b) b)
()
boot.lisp:20
EVAL_SUCCESS 1 1
(_m 1 _f 2 3)
3
boot.lisp:22
EVAL_ALL 8

(defbuiltin exit (exitcode))
(defbuiltin error (msg))

(defbuiltin gensym ())

(defbuiltin car (cons))
(defbuiltin cdr (cons))
boot.lisp:30
EVAL_SUCCESS 1 1
(car (cons 12 34))
12
boot.lisp:32
EVAL_SUCCESS 1 1
(cdr (cons 12 34))
34
boot.lisp:34
EVAL_ALL 2

(defbuiltin apply (f args))
boot.lisp:36
EVAL_SUCCESS 1 1
(apply cons (list 12 34))
(12 . 34)
boot.lisp:38
EVAL_ALL 3

(defun compose (f g)
  (fun (x) (f (g x))))
boot.lisp:41
EVAL_SUCCESS 1 1
((compose car cdr) (list 12 34 56))
34
boot.lisp:43
EVAL_ALL 3

(defun flip (f)
  (fun (a b) (f b a)))
boot.lisp:46
EVAL_SUCCESS 1 1
((flip (fun (a b) a)) 12 34)
34
boot.lisp:48
EVAL_ALL 3

(defun const (v)
  (fun _ v))
boot.lisp:51
EVAL_SUCCESS 1 1
((const 123))
123
boot.lisp:53
EVAL_SUCCESS 1 1
((const 123) 456 789)
123
boot.lisp:55
EVAL_ALL 24

(def caar (compose car car))
(def cadr (compose car cdr))
(def cdar (compose cdr car))
(def cddr (compose cdr cdr))
(def caaar (compose car caar))
(def cdaar (compose cdr caar))
(def cadar (compose car cdar))
(def cddar (compose cdr cdar))
(def caadr (compose car cadr))
(def cdadr (compose cdr cadr))
(def caddr (compose car cddr))
(def cdddr (compose cdr cddr))

(defbuiltin num? (x))
(defbuiltin sym? (x))
(defbuiltin str? (x))
(defbuiltin cons? (x))
(defbuiltin nil? (x))
(defbuiltin bool? (x))
(defbuiltin proc? (x))
(defbuiltin meta? (x))
(defbuiltin port? (x))
(defbuiltin vec? (x))
boot.lisp:79
EVAL_SUCCESS 1 1
(num? 123)
#t
boot.lisp:81
EVAL_FAILURE 1
(num? 12 34)
boot.lisp:83
EVAL_SUCCESS 1 1
(num? "foo")
#f
boot.lisp:85
EVAL_SUCCESS 1 1
(sym? 'foo)
#t
boot.lisp:87
EVAL_SUCCESS 1 1
(str? "foo")
#t
boot.lisp:89
EVAL_SUCCESS 1 1
(cons? (list 1 2 3))
#t
boot.lisp:91
EVAL_SUCCESS 1 1
(nil? ())
#t
boot.lisp:93
EVAL_SUCCESS 1 1
(list (bool? #t) (bool? ()))
(#t #f)
boot.lisp:95
EVAL_SUCCESS 1 1
(list (proc? (fun ())) (proc? cons) (proc? (macro ())) (proc? def))
(#t #t #f #f)
boot.lisp:97
EVAL_SUCCESS 1 1
(list (meta? (fun ())) (meta? cons) (meta? (macro ())) (meta? def))
(#f #f #t #t)
boot.lisp:99
EVAL_SUCCESS 1 1
(list (port? 123) (vec? 123))
(#f #f)
boot.lisp:101
EVAL_ALL 7

(defun list? (x)
  (if (nil? x)
    #t
    (if (cons? x)
      (list? (cdr x))
      #f)))
boot.lisp:108
EVAL_SUCCESS 1 1
(list? ())
#t
boot.lisp:110
EVAL_SUCCESS 1 1
(list? '(12 . 34))
#f
boot.lisp:112
EVAL_SUCCESS 1 1
(list? '(12 34 . 56))
#f
boot.lisp:114
EVAL_SUCCESS 1 1
(list? '(12 34 56))
#t
boot.lisp:116
EVAL_ALL 6

(defbuiltin + nums)
(defbuiltin - (num . nums))
(defbuiltin * nums)
(defbuiltin / (num . nums))
(defbuiltin % (num . nums))
boot.lisp:122
EVAL_SUCCESS 1 1
(list (+) (+ 11) (+ 3 4 5))
(0 11 12)
boot.lisp:124
EVAL_SUCCESS 1 1
(list (- 5) (- 5 2))
(-5 3)
boot.lisp:126
EVAL_SUCCESS 1 1
(list (*) (* 11) (* 3 4 5))
(1 11 60)
boot.lisp:128
EVAL_SUCCESS 1 1
(list (/ 2) (/ 20 5 2))
(0.5 2)
boot.lisp:130
EVAL_SUCCESS 1 1
(list (% 5) (% 5 3))
(5 2)
boot.lisp:132
EVAL_ALL 2

(defbuiltin = xs)
boot.lisp:134
EVAL_SUCCESS 1 1
(list (=) (= 1) (= 1 1) (= 1 2) (= 1 1 1) (= 1 1 2))
(#t #t #t #f #t #f)
boot.lisp:136
EVAL_SUCCESS 1 1
(list (= "foo" "foo") (= "foo" "bar"))
(#t #f)
boot.lisp:138
EVAL_SUCCESS 1 1
(list (= #t #t) (= #f #f) (= #t #f))
(#t #t #f)
boot.lisp:140
EVAL_SUCCESS 1 1
(list (= () ()) (= '(1 2) '(1 2)) (= '(1 2) '(1 3)) (= '(1 2 . 3) '(1 2 . 3)) (= '(1 2 3) '(1 2 . 3)))
(#t #t #f #t #f)
boot.lisp:142
EVAL_SUCCESS 1 1
(= (fun ()) (fun ()))
#f
boot.lisp:144
EVAL_SUCCESS 1 1
(list (= 123 "123") (= "foo" 'foo))
(#f #f)
boot.lisp:146
EVAL_ALL 5

(defbuiltin < nums-or-strs)
(defbuiltin > nums-or-strs)
(defbuiltin <= nums-or-strs)
(defbuiltin >= nums-or-strs)
boot.lisp:151
EVAL_SUCCESS 1 1
(list (<) (< 1) (< 1 2) (< 1 2 3) (< 1 3 3) (< 1 4 3) (< 4 3) (< 4 4 3))
(#t #t #t #t #f #f #f #f)
boot.lisp:153
EVAL_SUCCESS 1 1
(list (>) (> 1) (> 1 2) (> 1 2 3) (> 1 3 3) (> 1 4 3) (> 4 3) (> 4 4 3))
(#t #t #f #f #f #f #t #f)
boot.lisp:155
EVAL_SUCCESS 1 1
(list (<=) (<= 1) (<= 1 2) (<= 1 2 3) (<= 1 3 3) (<= 1 4 3) (<= 4 3) (<= 4 4 3))
(#t #t #t #t #t #f #f #f)
boot.lisp:157
EVAL_SUCCESS 1 1
(list (>=) (>= 1) (>= 1 2) (>= 1 2 3) (>= 1 3 3) (>= 1 4 3) (>= 4 3) (>= 4 4 3))
(#t #t #f #f #f #f #t #t)
boot.lisp:159
EVAL_SUCCESS 1 1
(list (< "abc" "cab") (< "abc" "abd") (< "bac" "acb"))
(#t #t #f)
boot.lisp:161
EVAL_FAILURE 1
(< 123 "456")
boot.lisp:163
EVAL_FAILURE 1
(< #f)
boot.lisp:165
EVAL_ALL 5

(defun map (f xs)
  (if (nil? xs)
    ()
    (cons (f (car xs)) (map f (cdr xs)))))
boot.lisp:170
EVAL_SUCCESS 1 1
(map (fun (a) (* a 3)) (list 1 2 5 4))
(3 6 15 12)
boot.lisp:172
EVAL_ALL 7

(defun filter (f xs)
  (if (nil? xs)
    ()
    (if (f (car xs))
      (cons (car xs) (filter f (cdr xs)))
      (filter f (cdr xs)))))
boot.lisp:179
EVAL_SUCCESS 1 1
(filter num? (list 1 2 "foo" 3 'bar 4))
(1 2 3 4)
boot.lisp:181
EVAL_ALL 2

(def for (flip map))
boot.lisp:183
EVAL_SUCCESS 1 1
(for (list 1 2 3) (fun (a) (* a a)))
(1 4 9)
boot.lisp:185
EVAL_ALL 5

(defun foldl (f i xs)
  (if (nil? xs)
    i
    (foldl f (f i (car xs)) (cdr xs))))
boot.lisp:190
EVAL_SUCCESS 1 1
(foldl cons () (list 2 5 3))
(((() . 2) . 5) . 3)
boot.lisp:192
EVAL_ALL 5

(defun foldr (f i xs)
  (if (nil? xs)
    i
    (f (car xs) (foldr f i (cdr xs)))))
boot.lisp:197
EVAL_SUCCESS 1 1
(foldr cons () (list 2 5 3))
(2 5 3)
boot.lisp:199
EVAL_ALL 8

(defun append ls
  (foldr *append () ls))

(defun *append (a b)
  (if (nil? a)
    b
    (cons (car a) (*append (cdr a) b))))
boot.lisp:207
EVAL_SUCCESS 1 1
(append (list 1 2 3) (list 4 5 6) (list 7 8))
(1 2 3 4 5 6 7 8)
boot.lisp:209
EVAL_ALL 3

(defun reverse (ls)
  (foldl (flip cons) () ls))
boot.lisp:212
EVAL_SUCCESS 1 1
(reverse (list 1 2 4 5))
(5 4 2 1)
boot.lisp:214
EVAL_ALL 5

(defun nth (n xs)
  (if (= n 0)
    (car xs)
    (nth (- n 1) (cdr xs))))
boot.lisp:219
EVAL_SUCCESS 1 1
(nth 3 (list 9 8 7 6 5))
6
boot.lisp:221
EVAL_ALL 5

(defun iota (a b)
  (if (< a b)
    (cons a (iota (+ a 1) b))
    '()))
boot.lisp:226
EVAL_SUCCESS 1 1
(iota 0 5)
(0 1 2 3 4)
boot.lisp:228
EVAL_SUCCESS 1 1
(iota 2 4)
(2 3)
boot.lisp:230
EVAL_SUCCESS 1 1
(iota 3 3)
()
boot.lisp:232
EVAL_ALL 3

(defun not (x)
  (if x #f #t))
boot.lisp:235
EVAL_SUCCESS 1 1
(map not (list 123 () #t #f))
(#f #f #f #t)
boot.lisp:237
EVAL_ALL 9

(def else #t)

(defmacro cond preds
  (if (nil? preds)
    ()
    (list 'if (caar preds)
          (cons 'begin (cdar preds))
          (cons 'cond (cdr preds)))))
boot.lisp:246
EVAL_SUCCESS 1 1
(cond)
()
boot.lisp:248
EVAL_SUCCESS 1 1
(cond [#t 123])
123
boot.lisp:250
EVAL_SUCCESS 1 1
(cond [#t 123 456])
456
boot.lisp:252
EVAL_SUCCESS 1 1
(cond [#t 1] [#t 2] [#t 3])
1
boot.lisp:254
EVAL_SUCCESS 1 1
(cond [#f 1] [#t 2] [#t 3])
2
boot.lisp:256
EVAL_SUCCESS 1 1
(cond [#f 1] [#f 2] [#t 3])
3
boot.lisp:258
EVAL_SUCCESS 1 1
(cond [#f 1] [#f 2] [#f 3])
()
boot.lisp:260
EVAL_SUCCESS 1 1
(def _r ())
()
boot.lisp:262
EVAL_SUCCESS 4 1
(cond
  [(begin (set! _r (cons 1 _r)) #f) (set! _r (cons 2 _r))]
  [(begin (set! _r (cons 3 _r)) #t) (set! _r (cons 4 _r))]
  [(begin (set! _r (cons 5 _r)) #t) (set! _r (cons 6 _r))])
()
boot.lisp:267
EVAL_SUCCESS 1 1
_r
(4 3 1)
boot.lisp:269
EVAL_ALL 10

(defmacro and values
  (cond
    [(nil? values) #t]
    [(nil? (cdr values)) (car values)]
    [else ((fun (tmp)
             (list (list 'fun (list tmp)
                         (list 'if tmp (cons 'and (cdr values)) tmp))
                   (car values)))
           (gensym))]))
boot.lisp:279
EVAL_SUCCESS 1 1
(and)
#t
boot.lisp:281
EVAL_SUCCESS 1 1
(and 123)
123
boot.lisp:283
EVAL_SUCCESS 1 1
(and 123 456)
456
boot.lisp:285
EVAL_SUCCESS 1 1
(and #f 456)
#f
boot.lisp:287
EVAL_SUCCESS 1 1
(and 123 456 789)
789
boot.lisp:289
EVAL_SUCCESS 1 1
(def _r ())
()
boot.lisp:291
EVAL_SUCCESS 5 1
(and
  (begin (set! _r (cons 1 _r)) 123)
  (begin (set! _r (cons 2 _r)) 456)
  (begin (set! _r (cons 3 _r)) #f)
  (begin (set! _r (cons 4 _r)) 789))
#f
boot.lisp:297
EVAL_SUCCESS 1 1
_r
(3 2 1)
boot.lisp:299
EVAL_ALL 10

(defmacro or values
  (cond
    [(nil? values) #f]
    [(nil? (cdr values)) (car values)]
    [else ((fun (tmp)
             (list (list 'fun (list tmp)
                         (list 'if tmp tmp (cons 'or (cdr values))))
                   (car values)))
           (gensym))]))
boot.lisp:309
EVAL_SUCCESS 1 1
(or)
#f
boot.lisp:311
EVAL_SUCCESS 1 1
(or 123)
123
boot.lisp:313
EVAL_SUCCESS 1 1
(or 123 456)
123
boot.lisp:315
EVAL_SUCCESS 1 1
(or #f 456)
456
boot.lisp:317
EVAL_SUCCESS 1 1
(or 123 456 789)
123
boot.lisp:319
EVAL_SUCCESS 1 1
(def _r ())
()
boot.lisp:321
EVAL_SUCCESS 5 1
(or
  (begin (set! _r (cons 1 _r)) #f)
  (begin (set! _r (cons 2 _r)) #f)
  (begin (set! _r (cons 3 _r)) 123)
  (begin (set! _r (cons 4 _r)) 456))
123
boot.lisp:327
EVAL_SUCCESS 1 1
_r
(3 2 1)
boot.lisp:329
EVAL_ALL 6

(defun all (f xs)
  (if (nil? xs)
    #t
    (and (f (car xs))
         (all f (cdr xs)))))
boot.lisp:335
EVAL_SUCCESS 1 1
(all num? (list))
#t
boot.lisp:337
EVAL_SUCCESS 1 1
(all num? (list 1 2 3))
#t
boot.lisp:339
EVAL_SUCCESS 1 1
(all num? (list 1 "2" 3))
#f
boot.lisp:341
EVAL_ALL 6

(defun any (f xs)
  (if (nil? xs)
    #f
    (or (f (car xs))
        (any f (cdr xs)))))
boot.lisp:347
EVAL_SUCCESS 1 1
(any num? (list))
#f
boot.lisp:349
EVAL_SUCCESS 1 1
(any num? (list 1 2 3))
#t
boot.lisp:351
EVAL_SUCCESS 1 1
(any num? (list "1" 2 "3"))
#t
boot.lisp:353
EVAL_SUCCESS 1 1
(any num? (list "1" "2" "3"))
#f
boot.lisp:355
EVAL_ALL 4

(defun partial (f . args-1)
  (fun args-2
    (apply f (append args-1 args-2))))
boot.lisp:359
EVAL_SUCCESS 1 1
((partial +))
0
boot.lisp:361
EVAL_SUCCESS 1 1
((partial -) 1)
-1
boot.lisp:363
EVAL_SUCCESS 1 1
((partial - 3) 1)
2
boot.lisp:365
EVAL_SUCCESS 1 1
((partial - 3 2) 1)
0
boot.lisp:367
EVAL_SUCCESS 1 1
((partial - 5 1) 2 3)
-1
boot.lisp:369
EVAL_ALL 51

(defmacro quasiquote ls
  (*qq 0 (car ls)))

(defun *qq (rank x)
  (if (cons? x)
    (cond
      [(= (car x) 'unquote)
       (if (= rank 0)
         (cadr x)
         (list 'list (list 'quote 'unquote) (*qq (- rank 1) (cadr x))))]
      [(and (cons? (car x)) (= (caar x) 'unquote-splicing))
       (if (= rank 0)
         (list 'append (cadar x) (*qq rank (cdr x)))
         (list 'cons (list 'list (list 'quote 'unquote-splicing) (*qq (- rank 1) (cadar x))) (*qq rank (cdr x))))]
      [(= (car x) 'quasiquote)
       (list 'list (list 'quote 'quasiquote) (*qq (+ rank 1) (cadr x)))]
      [else
        (list 'cons (*qq rank (car x)) (*qq rank (cdr x)))])
    (list 'quote x)))

(defun *bind? (x)
  (and (cons? x)
       (cons? (cdr x))
       (nil? (cddr x))
       (sym? (car x))))

(defmacro let (binds . body)
  (cond
    [(sym? binds)
      `(named-let ,binds ,@body)]
    [(nil? binds)
      `(begin ,@body)]
    [(not (and (cons? binds) (*bind? (car binds))))
      (error "Syntax error: expected (let ((name expr)...) body...)")]
    [else
      `((fun (,(caar binds)) (let ,(cdr binds) ,@body))
        ,(cadar binds))]))

(defmacro letrec (binds . body)
  (if (and (list? binds) (all *bind? binds))
    (let ([vars (map (fun (x) `[,(car x) ()]) binds)]
          [inits (map (fun (x) `(set! ,(car x) ,(cadr x))) binds)])
      `(let ,vars ,@inits ,@body))
    (error "Syntax error: expected (letrec ((name expr)...) body...)")))

(defmacro named-let (sym binds . body)
  (if (and (list? binds) (all *bind? binds))
    (let ([args (map car binds)])
      `(let ,binds (letrec ([,sym (fun ,args ,@body)]) (,sym ,@args))))
    (error "Syntax error: expected (named-let name ((name expr)...) body...)")))
boot.lisp:421
EVAL_SUCCESS 1 1
(let ([_x 2] [_y 3]) (* _x _y))
6
boot.lisp:423
EVAL_FAILURE 1
_x
boot.lisp:425
EVAL_SUCCESS 4 1
(let _loop ([x 10] [sum 0])
  (if (< 0 x)
    (_loop (- x 1) (+ sum x))
    sum))
55
boot.lisp:430
EVAL_FAILURE 1
_loop
boot.lisp:432
EVAL_SUCCESS 1 1
(let ([x 3] [x (* x 4)] [x (+ x 5)]) x)
17
boot.lisp:434
EVAL_SUCCESS 3 1
(letrec ([even? (fun (x) (if (= (% x 2) 0) #t (odd? (- x 1))))]
         [odd? (fun (x) (if (= (% x 2) 0) #f (even? (- x 1))))])
  (list (even? 4) (even? 5) (odd? 6) (odd? 7)))
(#t #f #f #t)
boot.lisp:438
EVAL_ALL 3

(defmacro when (cond . body)
  `(if ,cond (begin ,@body) ()))
boot.lisp:441
EVAL_SUCCESS 1 1
(when #f 123 456)
()
boot.lisp:443
EVAL_SUCCESS 1 1
(when #t 123 456)
456
boot.lisp:445
EVAL_ALL 3

(defmacro unless (cond . body)
  `(if ,cond () (begin ,@body)))
boot.lisp:448
EVAL_SUCCESS 1 1
(unless #f 123 456)
456
boot.lisp:450
EVAL_SUCCESS 1 1
(unless #t 123 456)
()
boot.lisp:452
EVAL_ALL 3

(defmacro let1 (var expr . body)
  `(let ([,var ,expr]) ,@body))
boot.lisp:455
EVAL_SUCCESS 4 1
(let1 x 3
  (let1 x (* x 4)
    (let1 x (+ x 5)
      x)))
17
boot.lisp:460
EVAL_ALL 5

(defbuiltin call/cc (fun))

(defmacro let/cc (k . body)
  `(call/cc (fun (,k) ,@body)))
boot.lisp:466
EVAL_SUCCESS 1 1
(+ 1 (let/cc cont (+ 10 (cont 100))))
101
boot.lisp:468
EVAL_SUCCESS 1 1
(+ 1 (let/cc cont (+ 10 100)))
111
boot.lisp:470
EVAL_SUCCESS 7 1
(let ([x 10] [sum 0] [cont #f])
  (let/cc k (set! cont k))
  (when (< 0 x)
    (set! sum (+ sum x))
    (set! x (- x 1))
    (cont))
  sum)
55
boot.lisp:478
EVAL_ALL 26

(defmacro shift (k . body)
  `(*shift (fun (,k) ,@body)))

(defmacro reset body
  `(*reset (fun () ,@body)))

(def *cont #f)

(defun *abort (thunk)
  (let1 v (thunk)
    (*cont v)))

(defun *reset (thunk)
  (let1 cont *cont
    (let/cc k
      (set! *cont (fun (v)
                    (set! *cont cont)
                    (k v)))
      (*abort thunk))))

(defun *shift (f)
  (let/cc k
    (*abort (fun ()
              (f (fun vs
                   (reset (apply k vs))))))))
boot.lisp:505
EVAL_SUCCESS 5 1
(reset
  (shift k (append '(1) (k)))
  (shift k (append '(2) (k)))
  (shift k (append '(3) (k)))
  '())
(1 2 3)
boot.lisp:511
EVAL_ALL 11

(defun success (v) (cons #t v))
(defun failure (v) (cons #f v))

(defun success? (v) (car v))
(defun failure? (v) (not (car v)))

(defun force-success (v)
  (if (success? v)
    (cdr v)
    (error (cdr v))))
boot.lisp:523
EVAL_SUCCESS 1 1
(force-success (success 123))
123
boot.lisp:525
EVAL_FAILURE 1
(force-success (failure "error"))
boot.lisp:527
EVAL_ALL 11

(def result-unit success)

(defun result-bind (m f)
  (if (success? m) (f (cdr m)) m))

(defmacro result-reify body
  `(reset (result-unit (begin ,@body))))

(defun result-reflect (m)
  (shift k (result-bind m k)))
boot.lisp:539
EVAL_SUCCESS 1 1
(result-reify 123)
(#t . 123)
boot.lisp:541
EVAL_SUCCESS 1 1
(result-reify (+ (result-reflect (success 123)) 456))
(#t . 579)
boot.lisp:543
EVAL_SUCCESS 1 1
(result-reify (+ (result-reflect (failure "error")) 456))
(#f . "error")
boot.lisp:545
EVAL_SUCCESS 1 1
(result-reify (let1 a (result-reify 123) (+ (result-reflect a) 1)))
(#t . 124)
boot.lisp:547
EVAL_SUCCESS 1 1
(result-reify (let1 a (result-reify (result-reflect (success 123))) (+ (result-reflect a) 1)))
(#t . 124)
boot.lisp:549
EVAL_SUCCESS 1 1
(result-reify (let1 a (result-reify (result-reflect (failure "error"))) (+ (result-reflect a) 1)))
(#f . "error")
boot.lisp:551
EVAL_SUCCESS 1 1
(result-reify (let1 a (result-reify (result-reflect (failure "error"))) a))
(#t #f . "error")
boot.lisp:553
EVAL_ALL 8

(def list-concat append)

(defun list-count (xs)
  (let loop ([xs xs] [c 0])
    (if (nil? xs)
      c
      (loop (cdr xs) (+ c 1)))))
boot.lisp:561
EVAL_SUCCESS 1 1
(list-count (list 1 3 4 5 6))
5
boot.lisp:563
EVAL_ALL 6

(defun list-find (f ls)
  (cond
    [(nil? ls) ()]
    [(f (car ls)) (car ls)]
    [else (list-find f (cdr ls))]))
boot.lisp:569
EVAL_SUCCESS 1 1
(list-find num? (list "foo" 'bar 123 "baz" 456))
123
boot.lisp:571
EVAL_SUCCESS 1 1
(list-find num? (list "foo" 'bar "baz"))
()
boot.lisp:573
EVAL_ALL 6

(defun list-lookup (k ls)
  (cond
    [(nil? ls) ()]
    [(= (caar ls) k) (cdar ls)]
    [else (list-lookup k (cdr ls))]))
boot.lisp:579
EVAL_SUCCESS 1 1
(list-lookup 2 '((1 . "foo") (2 . "bar") (3 . "baz")))
"bar"
boot.lisp:581
EVAL_SUCCESS 1 1
(list-lookup 5 '((1 . "foo") (2 . "bar") (3 . "baz")))
()
boot.lisp:583
EVAL_ALL 2

(def list-ref (flip nth))
boot.lisp:585
EVAL_SUCCESS 1 1
(list-ref (list 4 3 2) 0)
4
boot.lisp:587
EVAL_ALL 4

(def list-at nth)

(defbuiltin str bytes)
boot.lisp:591
EVAL_SUCCESS 1 1
(str 102)
"f"
boot.lisp:593
EVAL_SUCCESS 1 1
(str 102 111 111 98 97 114)
"foobar"
boot.lisp:595
EVAL_FAILURE 1
(str 260)
boot.lisp:597
EVAL_ALL 2

(defbuiltin str-ref (str n))
boot.lisp:599
EVAL_SUCCESS 1 1
(str-ref "foobar" 0)
102
boot.lisp:601
EVAL_SUCCESS 1 1
(str-ref "foobar" 1)
111
boot.lisp:603
EVAL_SUCCESS 1 1
(str-ref "foobar" 8)
()
boot.lisp:605
EVAL_ALL 4

(def str-at (flip str-ref))

(defbuiltin str-bytesize (str))
boot.lisp:609
EVAL_SUCCESS 1 1
(str-bytesize "foobar")
6
boot.lisp:611
EVAL_FAILURE 1
(str-bytesize "foobar" "baz")
boot.lisp:613
EVAL_SUCCESS 1 1
(str-bytesize "日本語")
9
boot.lisp:615
EVAL_ALL 3

(defun str->list (str)
  (map (partial str-ref str) (iota 0 (str-bytesize str))))
boot.lisp:618
EVAL_SUCCESS 1 1
(str->list "foobar")
(102 111 111 98 97 114)
boot.lisp:620
EVAL_ALL 3

(defun list->str (list)
  (apply str list))
boot.lisp:623
EVAL_SUCCESS 1 1
(list->str (list 102 111 111 98 97 114))
"foobar"
boot.lisp:625
EVAL_ALL 2

(defbuiltin str-concat strs)
boot.lisp:627
EVAL_SUCCESS 1 1
(str-concat)
""
boot.lisp:629
EVAL_SUCCESS 1 1
(str-concat "foo" "bar" "baz")
"foobarbaz"
boot.lisp:631
EVAL_ALL 2

(defbuiltin substr (str n bytesize))
boot.lisp:633
EVAL_SUCCESS 1 1
(substr "foobar" 0 3)
"foo"
boot.lisp:635
EVAL_SUCCESS 1 1
(substr "foobar" 2 3)
"oba"
boot.lisp:637
EVAL_SUCCESS 1 1
(substr "foobar" 1 4)
"ooba"
boot.lisp:639
EVAL_SUCCESS 1 1
(str->list (substr "日本語" 0 3))
(230 151 165)
boot.lisp:641
EVAL_FAILURE 1
(substr "foobar" 1 10)
boot.lisp:643
EVAL_ALL 2

(defbuiltin sym->str (sym))
boot.lisp:645
EVAL_SUCCESS 1 1
(sym->str 'foo-bar)
"foo-bar"
boot.lisp:647
EVAL_ALL 2

(defbuiltin num->str (num))
boot.lisp:649
EVAL_SUCCESS 1 1
(num->str 123)
"123"
boot.lisp:651
EVAL_ALL 2

(defbuiltin str->num (num))
boot.lisp:653
EVAL_SUCCESS 1 1
(str->num "456")
456
boot.lisp:655
EVAL_SUCCESS 1 1
(str->num "foo")
()
boot.lisp:657
EVAL_ALL 15

(defun str-escape (str)
  (list->str (*bytes-escape (str->list str))))

(defun *bytes-escape (bytes)
  (if (nil? bytes)
    ()
    (let ([l (car bytes)]
          [r (*bytes-escape (cdr bytes))])
      (cond
        [(= l 92) (append '(92  92) r)] ; \\
        [(= l  9) (append '(92 116) r)] ; \t
        [(= l 10) (append '(92 110) r)] ; \n
        [(= l 34) (append '(92  34) r)] ; \"
        [else (cons l r)]))))
boot.lisp:673
EVAL_SUCCESS 1 1
(str-escape "foo")
"foo"
boot.lisp:675
EVAL_SUCCESS 1 1
(str-escape "foo\"bar")
"foo\\\"bar"
boot.lisp:677
EVAL_SUCCESS 1 1
(str-escape "\t\t\n")
"\\t\\t\\n"
boot.lisp:679
EVAL_SUCCESS 1 1
(str-escape "peo\\ple")
"peo\\\\ple"
boot.lisp:681
EVAL_ALL 17

(defun str-unescape (str)
  (list->str (*bytes-unescape (str->list str))))

(defun *bytes-unescape (bytes)
  (cond
    [(or (nil? bytes) (nil? (cdr bytes))) bytes]
    [(= (car bytes) 92)
      (let ([l (cadr bytes)]
            [r (*bytes-unescape (cddr bytes))])
        (cond
          [(= l  92) (cons 92 r)] ; \\
          [(= l 116) (cons  9 r)] ; \t
          [(= l 110) (cons 10 r)] ; \n
          [(= l 34)  (cons 34 r)] ; \"
          [else (cons l r)]))]
    [else (cons (car bytes) (*bytes-unescape (cdr bytes)))]))
boot.lisp:699
EVAL_SUCCESS 1 1
(str-unescape "foo")
"foo"
boot.lisp:701
EVAL_SUCCESS 1 1
(str-unescape "foo\\\"bar")
"foo\"bar"
boot.lisp:703
EVAL_SUCCESS 1 1
(str-unescape "\\t\\t\\n")
"\t\t\n"
boot.lisp:705
EVAL_SUCCESS 1 1
(str-unescape "peo\\\\ple")
"peo\\ple"
boot.lisp:707
EVAL_ALL 2

(defbuiltin vec items)
boot.lisp:709
EVAL_SUCCESS 1 1
(vec 1 2 3)
(vec 1 2 3)
boot.lisp:711
EVAL_SUCCESS 1 1
(vec? (vec 1 2 3))
#t
boot.lisp:713
EVAL_ALL 2

(defbuiltin vec-make (length init))
boot.lisp:715
EVAL_SUCCESS 1 1
(vec-make 5 #f)
(vec #f #f #f #f #f)
boot.lisp:717
EVAL_ALL 2

(defbuiltin vec-ref (vec n))
boot.lisp:719
EVAL_SUCCESS 1 1
(vec-ref (vec 4 9 3) 1)
9
boot.lisp:721
EVAL_ALL 4

(def vec-at (flip vec-ref))

(defbuiltin vec-length (vec))
boot.lisp:725
EVAL_SUCCESS 1 1
(vec-length (vec))
0
boot.lisp:727
EVAL_SUCCESS 1 1
(vec-length (vec 1 2 3 4 5))
5
boot.lisp:729
EVAL_ALL 2

(defbuiltin vec-set! (vec n item))
boot.lisp:731
EVAL_SUCCESS 4 1
(let1 v (vec-make 3 #f)
  (vec-set! v 0 #t)
  (vec-set! v 2 "k")
  v)
(vec #t #f "k")
boot.lisp:736
EVAL_ALL 2

(defbuiltin vec-copy! (dest dest-start src src-start length))
boot.lisp:738
EVAL_SUCCESS 5 1
(let ([fs (vec-make 5 #f)]
      [ts (vec-make 3 #t)])
  (vec-set! ts 1 "k")
  (vec-copy! fs 1 ts 0 2)
  fs)
(vec #f #t "k" #f #f)
boot.lisp:744
EVAL_ALL 3

(defun vec->list (vec)
  (map (partial vec-ref vec) (iota 0 (vec-length vec))))
boot.lisp:747
EVAL_SUCCESS 1 1
(vec->list (vec 1 3 5 7))
(1 3 5 7)
boot.lisp:749
EVAL_ALL 3

(defun list->vec (list)
  (apply vec list))
boot.lisp:752
EVAL_SUCCESS 1 1
(list->vec (list 1 3 5 7))
(vec 1 3 5 7)
boot.lisp:754
EVAL_ALL 90

(defbuiltin open (filepath mode))
(defbuiltin close (port))

(def stdin ((builtin stdin)))
(def stdout ((builtin stdout)))
(def stderr ((builtin stderr)))

(defbuiltin read-byte (port))
(defbuiltin read-str (size port))
(defbuiltin read-line (port))

(defun read-all (port)
  (result-reify
    (let loop ([buf ""])
      (let ([str-read (result-reflect (read-str 4096 port))])
        (if (= 'eof str-read)
          buf
          (loop (str-concat buf str-read)))))))

(defun open-read (filepath)
  (result-reify
    (let ([port (result-reflect (open filepath "r"))]
          [r (result-reflect (read-all port))])
      (result-reflect (close port))
      r)))

(defun get-byte () (force-success (read-byte stdin)))
(defun get-line () (force-success (read-line stdin)))
(defun get-all () (force-success (read-all stdin)))

(defbuiltin write-byte (byte port))
(defbuiltin write-str (str port))
(defbuiltin write-line (str port))

(defun write-all (str port)
  (result-reify
    (let loop ([buf str])
      (let ([bytesize-wrote (result-reflect (write-str buf port))]
            [bytesize-rest (- (str-bytesize buf) bytesize-wrote)])
        (if (= 0 bytesize-rest)
          ()
          (loop (substr buf bytesize-wrote bytesize-rest)))))))

(defun write-newline (port)
  (write-line "" port))

(defun open-write (filepath str)
  (result-reify
    (let ([port (result-reflect (open filepath "w"))]
          [r (result-reflect (write-all str port))])
      (result-reflect (close port))
      r)))

(defun put-byte (byte) (force-success (write-byte byte stdout)))
(defun put-line (str) (force-success (write-line str stdout)))
(defun put-all (str) (force-success (write-all str stdout)))
(defun put-newline () (force-success (write-newline stdout)))

(defun inspect (x)
  (cond
    [(num? x) (num->str x)]
    [(sym? x) (sym->str x)]
    [(str? x) (str-concat "\"" (str-escape x) "\"")]
    [(cons? x) (let ([l (car x)]
                     [r (cdr x)]
                     [a (list-lookup l *syntax-sugar)])
                 (if (and (not (nil? a)) (cons? r) (nil? (cdr r)))
                   (str-concat a (inspect (car r)))
                   (str-concat "(" (*inspect-cons l r) ")")))]
    [(nil? x) "()"]
    [(= #t x) "#t"]
    [(= #f x) "#f"]
    [(proc? x) "<proc>"]
    [(meta? x) "<meta>"]
    [(port? x) "<port>"]
    [(vec? x) (inspect (cons 'vec (vec->list x)))]
    [else (error)]))

(def *syntax-sugar
  '((quote . "'")
    (quasiquote . "`")
    (unquote . ",")
    (unquote-splicing . ",@")))

(defun *inspect-cons (a b)
  (cond
    [(nil? b) (inspect a)]
    [(cons? b) (str-concat (inspect a) " " (*inspect-cons (car b) (cdr b)))]
    [else (str-concat (inspect a) " . " (inspect b))]))
boot.lisp:845
EVAL_SUCCESS 1 1
(inspect 123)
"123"
boot.lisp:847
EVAL_SUCCESS 1 1
(inspect 'foo)
"foo"
boot.lisp:849
EVAL_SUCCESS 1 1
(inspect "Hello, World!\n")
"\"Hello, World!\\n\""
boot.lisp:851
EVAL_SUCCESS 1 1
(inspect ())
"()"
boot.lisp:853
EVAL_SUCCESS 1 1
(inspect '(1))
"(1)"
boot.lisp:855
EVAL_SUCCESS 1 1
(inspect '(1 a "b"))
"(1 a \"b\")"
boot.lisp:857
EVAL_SUCCESS 1 1
(inspect '(foo . bar))
"(foo . bar)"
boot.lisp:859
EVAL_SUCCESS 1 1
(inspect '(foo bar . baz))
"(foo bar . baz)"
boot.lisp:861
EVAL_SUCCESS 1 1
(map inspect (list ''foo ''(bar baz)))
("'foo" "'(bar baz)")
boot.lisp:863
EVAL_SUCCESS 1 1
(inspect '`(foo ,bar ,@baz))
"`(foo ,bar ,@baz)"
boot.lisp:865
EVAL_SUCCESS 1 1
(inspect '(quote foo bar))
"(quote foo bar)"
boot.lisp:867
EVAL_SUCCESS 1 1
(inspect '(quote . foo))
"(quote . foo)"
boot.lisp:869
EVAL_SUCCESS 1 1
(map inspect '(#t #f))
("#t" "#f")
boot.lisp:871
EVAL_SUCCESS 1 1
(map inspect (list (fun ()) = (macro ()) def))
("<proc>" "<proc>" "<meta>" "<meta>")
boot.lisp:873
EVAL_SUCCESS 1 1
(map inspect (list stdin stdout stderr))
("<port>" "<port>" "<port>")
boot.lisp:875
EVAL_SUCCESS 1 1
(inspect (vec 1 2 3))
"(vec 1 2 3)"
boot.lisp:877
EVAL_ALL 16

(defun print strs
  (map put-all strs)
  ())

(defun println strs
  (map put-all strs)
  (put-newline)
  ())

(defun p xs
  (apply println (map inspect xs)))

(def args ((builtin args)))

(defbuiltin eval (s))
boot.lisp:893
EVAL_SUCCESS 1 1
(force-success (eval '(+ 1 2 3)))
6
boot.lisp:895
EVAL_FAILURE 1
(force-success (eval '(error)))
boot.lisp:897
EVAL_ALL 3

(defbuiltin macroexpand (s))
(defbuiltin macroexpand-1 (s))
boot.lisp:900
EVAL_SUCCESS 1 1
(force-success (macroexpand 123))
123
boot.lisp:902
EVAL_SUCCESS 1 1
(force-success (macroexpand '(defun foo (x y) (+ x y))))
(def foo (fun (x y) (+ x y)))
boot.lisp:904
EVAL_SUCCESS 1 1
(def _skip (macro (a . b) b))
()
boot.lisp:906
EVAL_SUCCESS 1 1
(force-success (macroexpand '(_skip 12 _skip 34 list 56 78)))
(list 56 78)
boot.lisp:908
EVAL_SUCCESS 1 1
(force-success (macroexpand-1 '(_skip 12 _skip 34 list 56 78)))
(_skip 34 list 56 78)
boot.lisp:910
EVAL_SUCCESS 1 1
(force-success (macroexpand '(list 12 (_skip 34 list 56 78))))
(list 12 (list 56 78))
boot.lisp:912
EVAL_SUCCESS 1 1
(force-success (macroexpand-1 '(list 12 (_skip 34 list 56 78))))
(list 12 (_skip 34 list 56 78))
boot.lisp:914
EVAL_FAILURE 1
(force-success (macroexpand '(_skip)))
contrib/stream.lisp:1
EVAL_ALL 41
; <stream> = (vec 'stream <cursor> forward)
; <cursor> = () | (cons item <stream>)
(defun stream (input)
  (def stream-head (vec 'stream () ()))
  (defun forward ()
    (let1 next-stream-head (vec 'stream () forward)
      (vec-set! stream-head 1 (cons (input) next-stream-head))
      (set! stream-head next-stream-head)))
  (vec-set! stream-head 2 forward)
  stream-head)

(defun stream? (v)
  (and (vec? v)
       (= (vec-ref v 0) 'stream)))

(defun stream-peek (s)
  (when (nil? (vec-ref s 1)) ((vec-ref s 2)))
  (car (vec-ref s 1)))

(defun stream-next (s)
  (if (= (stream-peek s) 'eof)
    s
    (cdr (vec-ref s 1))))

(defun stream-get (s)
  (if (stream-eof? s)
    (failure "eof")
    (let ([r (stream-peek s)]
          [s (stream-next s)])
      (success (cons r s)))))

(defun stream-take (n s)
  (result-reify
    (let loop ([n n] [s s])
      (if (= n 0)
        ()
        (let1 r (result-reflect (stream-get s))
          (cons (car r) (loop (- n 1) (cdr r))))))))

(defun stream-eof? (s)
  (= (stream-peek s) 'eof))
contrib/stream.lisp:43
EVAL_SUCCESS 1 1
(def _x 0)
()
contrib/stream.lisp:45
EVAL_SUCCESS 1 1
(def _s1 (stream (fun () (set! _x (+ _x 1)) _x)))
()
contrib/stream.lisp:47
EVAL_SUCCESS 1 1
(stream-peek _s1)
1
contrib/stream.lisp:49
EVAL_SUCCESS 1 1
(stream-peek _s1)
1
contrib/stream.lisp:51
EVAL_SUCCESS 1 1
(def _s2 (stream-next _s1))
()
contrib/stream.lisp:53
EVAL_SUCCESS 1 1
(cons (stream-peek _s1) (stream-peek _s2))
(1 . 2)
contrib/stream.lisp:55
EVAL_SUCCESS 1 1
(set! _s1 (stream-next (stream-next _s1)))
()
contrib/stream.lisp:57
EVAL_SUCCESS 1 1
(cons (stream-peek _s1) (stream-peek _s2))
(3 . 2)
contrib/stream.lisp:59
EVAL_SUCCESS 1 1
(set! _s1 (force-success (stream-get _s1)))
()
contrib/stream.lisp:61
EVAL_SUCCESS 1 1
(cons (car _s1) (stream-peek (cdr _s1)))
(3 . 4)
contrib/stream.lisp:63
EVAL_SUCCESS 1 1
(force-success (stream-take 4 _s2))
(2 3 4 5)
contrib/stream.lisp:65
EVAL_ALL 9

(defun list->stream (ls)
  (stream
    (fun ()
      (if (nil? ls)
        'eof
        (let1 r (car ls)
          (set! ls (cdr ls))
          r)))))
contrib/stream.lisp:74
EVAL_SUCCESS 1 1
(force-success (stream-take 4 (list->stream (list 1 2 3 4 5))))
(1 2 3 4)
contrib/stream.lisp:76
EVAL_ALL 5

(defun stream->list (s)
  (if (stream-eof? s)
    ()
    (cons (stream-peek s) (stream->list (stream-next s)))))
contrib/stream.lisp:81
EVAL_SUCCESS 1 1
(stream->list (list->stream (list 1 2 3)))
(1 2 3)
contrib/stream.lisp:83
EVAL_ALL 10

(defun str->stream (str)
  (let1 i 0
    (stream
      (fun ()
        (if (< i (str-bytesize str))
          (let1 r (str-ref str i)
            (set! i (+ i 1))
            r)
          'eof)))))
contrib/stream.lisp:93
EVAL_SUCCESS 1 1
(force-success (stream-take 3 (str->stream "abc")))
(97 98 99)
contrib/stream.lisp:95
EVAL_FAILURE 1
(force-success (stream-take 4 (str->stream "abc")))
contrib/stream.lisp:97
EVAL_ALL 3

(defun stream->str (s)
  (apply str (stream->list s)))
contrib/stream.lisp:100
EVAL_SUCCESS 1 1
(stream->str (list->stream (list 97 98 99)))
"abc"
contrib/stream.lisp:102
EVAL_ALL 5

(defun port->stream (port)
  (stream
    (fun ()
      (force-success (read-byte port)))))
contrib/parser-combinators.lisp:1
EVAL_ALL 65
; input -> (result . input) | #f
; tested in parser-combinators-stream

(defun parse (p i)
  (p i))

(defun p-unit (x)
  (fun (i) (cons x i)))

(defun p-bind (m f)
  (fun (i)
    (let1 x (m i)
      (and x ((f (car x)) (cdr x))))))

(def p-fail
  (fun (i) #f))

(defmacro p-reify body
  `(reset (p-unit (begin ,@body))))

(defun p-reflect (m)
  (shift k (p-bind m k)))

;;;;

(defmacro p-lazy (p)
  `(fun (i) (,p i)))

(defun p-map (f p)
  (p-reify
    (let1 x (p-reflect p)
      (f x))))

(defun p-where (f p)
  (fun (i)
    (let1 x (p i)
      (and x (f (car x)) x))))

(defun p-or (p q)
  (fun (i)
    (or (p i) (q i))))

(defun p-cons (p q)
  (p-reify
    (let ([x (p-reflect p)]
          [y (p-reflect q)])
      (cons x y))))

(def p-nil (p-unit ()))

(defun p-choice ps
  (foldr p-or p-fail ps))

(defun p-seq ps
  (foldr p-cons p-nil ps))

(defun p-some (p)
  (p-cons p (p-many p)))

(defun p-many (p)
  (p-lazy
    (p-choice (p-some p) p-nil)))

(defun p-reduce (f . args)
  (p-map (partial apply f) (apply p-seq args)))
contrib/parser-combinators-stream.lisp:1
EVAL_ALL 24
; Predicates

(defun char-class (s)
  (let ([inverse? (= (str-ref s 0) 94)]
        [ls (str->list s)]
        [fs (*char-class (if inverse? (cdr ls) ls))])
    (if inverse?
      (fun (i) (all (fun (f) (not (f i))) fs))
      (fun (i) (any (fun (f) (f i)) fs)))))

(defun *char-class (ls)
  (cond
    [(nil? ls) ()]
    [(or (nil? (cdr ls)) (nil? (cddr ls))) (map *char-class-unit ls)]
    [(= (nth 1 ls) 45) (cons (*char-class-range (nth 0 ls) (nth 2 ls))
                             (*char-class (cdddr ls)))]
    [else (cons (*char-class-unit (car ls))
                (*char-class (cdr ls)))]))

(defun *char-class-unit (x)
  (fun (i) (= i x)))

(defun *char-class-range (x y)
  (fun (i) (<= x i y)))
contrib/parser-combinators-stream.lisp:26
EVAL_SUCCESS 1 1
(map (char-class "a-fstx-z") (str->list "abcfgtuwy"))
(#t #t #t #t #f #t #f #f #t)
contrib/parser-combinators-stream.lisp:28
EVAL_SUCCESS 1 1
(map (char-class "^a-fstx-z") (str->list "abcfgtuwy"))
(#f #f #f #f #t #f #t #t #f)
contrib/parser-combinators-stream.lisp:30
EVAL_ALL 3

;;;;
; Parser combinators
contrib/parser-combinators-stream.lisp:34
EVAL_SUCCESS 3 1
(defun ps-test (p str)
  (let1 r (parse p (str->stream str))
    (and r (cons (car r) (stream->str (cdr r))))))
()
contrib/parser-combinators-stream.lisp:38
EVAL_ALL 3

(defun ps-any (i)
  (and (not (= (stream-peek i) 'eof)) (cons (stream-peek i) (stream-next i))))
contrib/parser-combinators-stream.lisp:41
EVAL_SUCCESS 1 1
(ps-test ps-any "abc")
(97 . "bc")
contrib/parser-combinators-stream.lisp:43
EVAL_SUCCESS 1 1
(ps-test ps-any "")
#f
contrib/parser-combinators-stream.lisp:45
EVAL_ALL 3

(defun ps-eof (i)
  (and (= (stream-peek i) 'eof) (cons () i)))
contrib/parser-combinators-stream.lisp:48
EVAL_SUCCESS 1 1
(ps-test ps-eof "")
(() . "")
contrib/parser-combinators-stream.lisp:50
EVAL_SUCCESS 1 1
(ps-test ps-eof "abc")
#f
contrib/parser-combinators-stream.lisp:52
EVAL_ALL 2

; p-unit
contrib/parser-combinators-stream.lisp:54
EVAL_SUCCESS 1 1
(ps-test (p-unit "Hello") "abc")
("Hello" . "abc")
contrib/parser-combinators-stream.lisp:56
EVAL_ALL 2

; p-bind
contrib/parser-combinators-stream.lisp:58
EVAL_SUCCESS 3 1
(ps-test (p-bind ps-any (fun (a)
           (p-bind ps-any (fun (b)
             (p-unit (cons a b)))))) "abc")
((97 . 98) . "c")
contrib/parser-combinators-stream.lisp:62
EVAL_ALL 2

; p-fail
contrib/parser-combinators-stream.lisp:64
EVAL_SUCCESS 1 1
(ps-test p-fail "abc")
#f
contrib/parser-combinators-stream.lisp:66
EVAL_SUCCESS 3 1
(ps-test (p-bind ps-any (fun (a)
           (p-bind p-fail (fun (b)
             (p-unit (cons a b)))))) "abc")
#f
contrib/parser-combinators-stream.lisp:70
EVAL_ALL 4

(def ps-char
  (p-map str ps-any))
; p-map
contrib/parser-combinators-stream.lisp:74
EVAL_SUCCESS 1 1
(ps-test ps-char "abc")
("a" . "bc")
contrib/parser-combinators-stream.lisp:76
EVAL_ALL 4

(defun ps-if (f)
  (p-where f ps-any))
; p-where
contrib/parser-combinators-stream.lisp:80
EVAL_SUCCESS 1 1
(ps-test (ps-if (char-class "ab")) "abc")
(97 . "bc")
contrib/parser-combinators-stream.lisp:82
EVAL_SUCCESS 1 1
(ps-test (ps-if (char-class "ab")) "def")
#f
contrib/parser-combinators-stream.lisp:84
EVAL_ALL 3

(defun ps-char-if (f)
  (p-map str (ps-if f)))
contrib/parser-combinators-stream.lisp:87
EVAL_SUCCESS 1 1
(ps-test (ps-char-if (char-class "ab")) "abc")
("a" . "bc")
contrib/parser-combinators-stream.lisp:89
EVAL_ALL 2

; p-or, p-choice
contrib/parser-combinators-stream.lisp:91
EVAL_SUCCESS 8 1
(let ([ab (ps-char-if (char-class "ab"))]
      [ac (ps-char-if (char-class "ac"))]
      [add-suffix (fun (s) (str-concat s "-"))]
      [p (p-choice ab (p-map add-suffix ac))])
  (list (ps-test p "abcd")
        (ps-test p "bcda")
        (ps-test p "cdab")
        (ps-test p "dabc")))
(("a" . "bcd") ("b" . "cda") ("c-" . "dab") #f)
contrib/parser-combinators-stream.lisp:100
EVAL_ALL 2

; p-cons, p-nil, p-seq
contrib/parser-combinators-stream.lisp:102
EVAL_SUCCESS 7 1
(let1 p (p-seq (ps-char-if (char-class "ab"))
               (ps-char-if (char-class "12"))
               (ps-char-if (char-class "xy")))
  (list (ps-test p "c2xo")
        (ps-test p "a3yp")
        (ps-test p "b1zq")
        (ps-test p "a1xr")))
(#f #f #f (("a" "1" "x") . "r"))
contrib/parser-combinators-stream.lisp:110
EVAL_ALL 6

(defun ps-list (xs)
  (apply p-seq (map (fun (x) (ps-if (fun (y) (= x y)))) xs)))

(defun ps-str (s)
  (p-map (const s) (ps-list (str->list s))))
contrib/parser-combinators-stream.lisp:117
EVAL_SUCCESS 1 1
(ps-test (ps-str "foo") "bar")
#f
contrib/parser-combinators-stream.lisp:119
EVAL_SUCCESS 1 1
(ps-test (ps-str "bar") "bar")
("bar" . "")
contrib/parser-combinators-stream.lisp:121
EVAL_SUCCESS 1 1
(ps-test (ps-str "baz") "bar")
#f
contrib/parser-combinators-stream.lisp:123
EVAL_ALL 2

; p-many, p-some
contrib/parser-combinators-stream.lisp:125
EVAL_SUCCESS 9 1
(let ([p0 (p-many (ps-str "a"))]
      [p1 (p-some (ps-str "a"))])
  (list (ps-test p0 "")
        (ps-test p0 "a")
        (ps-test p0 "aaa")
        (ps-test p0 "aabb")
        (ps-test p1 "")
        (ps-test p1 "a")
        (ps-test p1 "aabb")))
((() . "") (("a") . "") (("a" "a" "a") . "") (("a" "a") . "bb") #f (("a") . "") (("a" "a") . "bb"))
contrib/parser-combinators-stream.lisp:135
EVAL_ALL 2

; p-reduce
contrib/parser-combinators-stream.lisp:137
EVAL_SUCCESS 3 1
(ps-test (p-reduce + (p-map (fun (n) (* n 10000)) ps-any)
                     (p-map (fun (n) (* n 100)) ps-any)
                     ps-any) "abcdef")
(979899 . "def")
contrib/parser-combinators-stream.lisp:141
EVAL_ALL 3

(defun ps-str-while (f)
  (p-map (fun (ls) (apply str ls)) (p-some (ps-if f))))
contrib/parser-combinators-stream.lisp:144
EVAL_SUCCESS 1 1
(ps-test (ps-str-while (char-class "abc")) "ababcbadcba")
("ababcba" . "dcba")
contrib/parser-combinators-stream.lisp:146
EVAL_SUCCESS 1 1
(ps-test (ps-str-while (char-class "abc")) "defabcdef")
#f
contrib/tbl.lisp:1
EVAL_ALL 118
(defun *str-hash (str)
  (let loop ([i 0]
             [r 0]
             [p 1])
    (if (<= (str-bytesize str) i)
      r
      (loop (+ i 1)
            (+ r (* p (str-ref str i)))
            (% (* p 257) 2038177)))))

(def *tbl-capacity-provider
  (list->stream (list 17 31 61 101 211 421 877 1663 3323 6871 14173 28439 57457 112771 232607)))

(def *tbl-threshold 0.8)

(defun *tbl-f (hash M)
  (% hash M))

(defun *tbl-g (hash M)
  (+ 1 (% hash (- M 1))))

(defun *tbl-h (hash M i)
  (% (+ (*tbl-f hash M)
        (* i (*tbl-g hash M)))
     M))

; <tbl> = (vec 'tbl capacity-stream length removed <payload>)
; <payload> = (vec <item> ...)
; <item> = (key . value) | key | #f

(defun tbl ()
  (let1 t (vec-make 5 ())
    (vec-set! t 0 'tbl)
    (tbl-clear! t)
    t))

(defun tbl-clear! (t)
  (vec-set! t 1 *tbl-capacity-provider)
  (vec-set! t 2 0)
  (vec-set! t 3 0)
  (vec-set! t 4 (vec-make (stream-peek *tbl-capacity-provider) #f)))

(defun tbl? (x)
  (and (vec? x)
       (= (vec-ref x 0) 'tbl)))

(defun *tbl-capacity (tbl) (vec-ref tbl 1))
(defun *tbl-length-total (tbl) (vec-ref tbl 2))
(defun *tbl-length-removed (tbl) (vec-ref tbl 3))
(defun *tbl-payload (tbl) (vec-ref tbl 4))

(defun tbl-justify! (tbl additional-capacity)
  (let ([payload-required-length (+ (*tbl-length-total tbl) additional-capacity)]
        [required-length (- payload-required-length (*tbl-length-removed tbl))]
        [usable-length (* (stream-peek (*tbl-capacity tbl)) *tbl-threshold)])
    ; NOTE: tbl never shrinks.
    (when (< usable-length payload-required-length)
      (let ([payload (*tbl-payload tbl)]
            [new-capacity (*tbl-forward-capacity (*tbl-capacity tbl) required-length)]
            [new-payload (vec-make (stream-peek new-capacity) #f)])
        (vec-set! tbl 1 new-capacity)
        (vec-set! tbl 2 0)
        (vec-set! tbl 3 0)
        (vec-set! tbl 4 new-payload)
        (*tbl-migrate! payload tbl)))))

(defun *tbl-forward-capacity (s length)
  (cond
    [(= 'eof (stream-peek s)) (error "Too much elements")]
    [(< (* (stream-peek s) *tbl-threshold) length) (*tbl-forward-capacity (stream-next s) length)]
    [else s]))

(defun *tbl-migrate! (payload tbl)
  (let loop ([i 0])
    (when (< i (vec-length payload))
      (let1 item (vec-ref payload i)
        (when (cons? item)
          (tbl-insert! tbl (car item) (cdr item)))
        (loop (+ i 1))))))

(defun *tbl-find-index (tbl key)
  (let ([M (stream-peek (*tbl-capacity tbl))]
        [hash (*str-hash key)]
        [match? (fun (v)
                  (or (not v)
                      (= v key)
                      (and (cons? v) (= (car v) key))))])
    (let loop ([i 0])
      (let1 index (*tbl-h hash M i)
        (if (match? (vec-ref (*tbl-payload tbl) index))
          index
          (loop (+ i 1)))))))

(defun *tbl-find (tbl key)
  (vec-ref (*tbl-payload tbl) (*tbl-find-index tbl key)))

(defun tbl-contains? (tbl key)
  (cons? (*tbl-find tbl key)))

(defun tbl-find (tbl key)
  (let1 r (*tbl-find tbl key)
    (if (cons? r) (cdr r) ())))

(defun tbl-insert! (tbl key value)
  (tbl-justify! tbl 1)
  (let ([index (*tbl-find-index tbl key)]
        [prev (vec-ref (*tbl-payload tbl) index)])
    (vec-set! (*tbl-payload tbl) index (cons key value))
    (cond
      [(not prev) (vec-set! tbl 2 (+ (*tbl-length-total tbl) 1))]
      [(str? prev) (vec-set! tbl 3 (- (*tbl-length-removed tbl) 1))])))

(defun tbl-remove! (tbl key)
  (let ([index (*tbl-find-index tbl key)]
        [prev (vec-ref (*tbl-payload tbl) index)])
    (when (cons? prev)
      (vec-set! (*tbl-payload tbl) index key)
      (vec-set! tbl 3 (+ (*tbl-length-removed tbl) 1)))))
contrib/tbl.lisp:120
EVAL_SUCCESS 1 1
(tbl? (tbl))
#t
contrib/tbl.lisp:122
EVAL_SUCCESS 1 1
(tbl? 123)
#f
contrib/tbl.lisp:124
EVAL_SUCCESS 1 1
(def _t (tbl))
()
contrib/tbl.lisp:126
EVAL_SUCCESS 1 1
(tbl-contains? _t "foo")
#f
contrib/tbl.lisp:128
EVAL_SUCCESS 1 1
(tbl-insert! _t "foo" 123)
()
contrib/tbl.lisp:130
EVAL_SUCCESS 1 1
(tbl-contains? _t "foo")
#t
contrib/tbl.lisp:132
EVAL_SUCCESS 1 1
(tbl-find _t "foo")
123
contrib/tbl.lisp:134
EVAL_SUCCESS 1 1
(list (tbl-contains? _t "bar") (tbl-find _t "bar"))
(#f ())
contrib/tbl.lisp:136
EVAL_SUCCESS 1 1
(tbl-insert! _t "bar" 456)
()
contrib/tbl.lisp:138
EVAL_SUCCESS 1 1
(list (tbl-find _t "foo") (tbl-find _t "bar") (tbl-find _t "baz"))
(123 456 ())
contrib/tbl.lisp:140
EVAL_SUCCESS 1 1
(tbl-remove! _t "foo")
()
contrib/tbl.lisp:142
EVAL_SUCCESS 1 1
(tbl-remove! _t "baz")
()
contrib/tbl.lisp:144
EVAL_SUCCESS 1 1
(list (tbl-find _t "foo") (tbl-find _t "bar") (tbl-find _t "baz"))
(() 456 ())
contrib/tbl.lisp:146
EVAL_SUCCESS 1 1
(begin (for (iota 0 1000) (fun (i) (tbl-insert! _t (num->str i) (* i 2)))) ())
()
contrib/tbl.lisp:148
EVAL_SUCCESS 1 1
(foldr + 0 (map (fun (i) (tbl-find _t (num->str i))) (iota 0 301)))
90300
contrib/tbl.lisp:150
EVAL_ALL 7

(defun *tbl-information (tbl)
  (list 'tbl-information
        (list 'capacity (stream-peek (*tbl-capacity tbl)))
        (list 'used (*tbl-length-total tbl))
        (list 'removed (*tbl-length-removed tbl))
        (list 'items (filter cons? (vec->list (*tbl-payload tbl))))))
